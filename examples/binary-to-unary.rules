-- Convert binary numerals into unary strings without lookup tables.
--
-- Layout: after setup the tape reads `BINARY@UNARY!`, where the section to the
-- right of `@` stores the gradually constructed unary count. Each iteration
-- subtracts one from the binary prefix and appends a `1` on the unary side.
-- When no `1` remains on the left, the finalisation stage erases the binary
-- scaffold and swaps the trailing `!` for the guard `|`.
--
-- Markers:
--   R – scans left across the binary digits during subtraction.
--   z – temporary tag for zeros that were borrowed; becomes `1` on the way back.
--   T – propagates right after the borrow completes, restoring digits and
--        handing control to the unary append phase.
--   P – walks through the unary suffix and appends a fresh `1` before `!`.
--   F/G – finalisation markers used once the binary section reaches zero.
--
-- Guard: once a bar appears anywhere, halt immediately.
| -> |;

-- Stage 2: walk `R` left, marking borrowed zeros and stopping on the right-most
-- `1`. If no `1` exists, fall through to the finalisation branch.
0R -> Rz;
1R -> T0;
R -> F;

-- Stage 3: propagate `T` back to the boundary, turning borrowed zeros into
-- ones as it moves right and then queuing the unary append phase.
Tz -> 1T;
T0 -> 0T;
T1 -> 1T;
T@ -> @P;

-- Stage 4: append a unary `1` immediately before the sentinel `!`.
P1 -> 1P;
P! -> 1!;

-- Stage 5: binary section exhausted. Strip the left half and reveal the guard.
F0 -> F;
F1 -> F;
Fz -> F;
F@ -> G;
G1 -> 1G;
G! -> |;

-- Stage 1: begin an iteration by seeding the scan marker to the left of `@`.
@ -> R@;

-- Stage 0: append the workspace `@!` to any plain binary input. Placing these
-- rules last ensures they run only when no later stage applies.
.1 -> 1.;
.0 -> 0.;
. -> @!;
1 -> .1;
0 -> .0;
-> @!;
